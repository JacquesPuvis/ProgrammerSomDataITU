Hello Mr. Ladegaard, 
We present to you today's offerings brought to you by the fruit of our personal sacrifices. 

We have slayed this assignment, but exercise 8.1 was incredibly long, so kindly inspect each 
line closely (only kidding, we care for your sanity).

All yours, 
Dadler <3
_________________________________________________________________________

Exercise 8.1

PART 1:

compileToFile (fromFile "ex3.c") "ex3.out";;  
val it: Machine.instr list =
  [LDARGS;                                          //load command line with argument n
  CALL (1, "L1");                                   //call main
  STOP;                                             //end program
  Label "L1";                                       //void main(int n)
    INCSP 1;                                        //int i
    GETBP; CSTI 1; ADD;                             //adress for i 
    CSTI 0; STI; INCSP -1;                          //i = 0
    GOTO "L3";                                      //go to condition of while loop
  Label "L2";                                       //loop body
    GETBP; CSTI 1; ADD; LDI; PRINTI; INCSP -1;      //get i and print i 
    GETBP; CSTI 1; ADD; GETBP; CSTI 1; ADD;         //get i, get i, add 1
        LDI; CSTI 1; ADD; STI; INCSP -1; 
    INCSP 0;                                        //no operation
  Label "L3";                                       //condition i < n
    GETBP; CSTI 1; ADD; LDI;                        //get i
    GETBP; CSTI 0; ADD; LDI;                        //get n
    LT;                                             //<
    IFNZRO "L2";                                    //if true go to L2
    INCSP -1;                                       //if not true pop condition from stack (end loop)
    RET 0]                                          //function end


PART 2:

compile "ex5";;
val it: Machine.instr list =
  [LDARGS;                                          //load command line with argument n
  CALL (1, "L1");                                   //call main          
  STOP;                                             //end program
  Label "L1";                                       //void main(int n)
    INCSP 1;                                        //inr r
    GETBP; CSTI 1; ADD;                             //get adress for r
    GETBP; CSTI 0; ADD; LDI;                        //get n
    STI; INCSP -1;                                  //r = n 
    INCSP 1;                                        //new int r
    GETBP; CSTI 0; ADD; LDI;                        //get n
    GETBP; CSTI 2; ADD;                             //get adress for new r
    CALL (2, "L2");                                 //call square function (L2) with 2 arguments
    INCSP -1;                                       //end block (end call to square)
    GETBP; CSTI 2; ADD; LDI;                        //get r         
    PRINTI; INCSP -1;                               //print r
    INCSP -1;                                       //pop print argument (end block) and make new r a free variable
    GETBP; CSTI 1; ADD; LDI;                        //get r
    PRINTI; INCSP -1;                               //print r
    INCSP -1;                                       //end block
    RET 0;                                          //function end
  Label "L2";                                       //void square(int i, int *rp)
    GETBP; CSTI 1; ADD; LDI;                        //get *rp (pointer value to r) (argument index 1)
    GETBP; CSTI 0; ADD; LDI;                        //get i (argument index 0)
    GETBP; CSTI 0; ADD; LDI;                        //get i (argument index 0)
    MUL;                                            //multiply i with i
    STI;                                            //assign *rp the value of the multiplication
    INCSP -1;                                       //pop leftover addresses, end block
    INCSP 0;                                        //no operation
    RET 1]                                          //return *rp

PART 3: 

[ ]{0: LDARGS}                       // push command-line arg n (=4)
[ 4 ]{1: CALL 1 5}                   // call main(n); set frame; jump to L1 at pc=5
[ 4 -999 4 ]{5: INCSP 1}             // allocate local i (slot [BP+1])
[ 4 -999 4 0 ]{7: GETBP}             // push BP
[ 4 -999 4 0 2 ]{8: CSTI 1}          // push 1
[ 4 -999 4 0 2 1 ]{10: ADD}          // compute &i = BP+1
[ 4 -999 4 0 3 ]{11: CSTI 0}         // push 0
[ 4 -999 4 0 3 0 ]{13: STI}          // i = 0
[ 4 -999 4 0 0 ]{14: INCSP -1}       // pop temp
[ 4 -999 4 0 ]{16: GOTO 43}          // jump to while test

[ 4 -999 4 0 ]{43: GETBP}            // while test: push BP
[ 4 -999 4 0 2 ]{44: CSTI 1}         // push 1
[ 4 -999 4 0 2 1 ]{46: ADD}          // addr(i)
[ 4 -999 4 0 3 ]{47: LDI}            // load i
[ 4 -999 4 0 0 ]{48: GETBP}          // push BP
[ 4 -999 4 0 0 2 ]{49: CSTI 0}       // push 0
[ 4 -999 4 0 0 2 0 ]{51: ADD}        // addr(n)
[ 4 -999 4 0 0 2 ]{52: LDI}          // load n
[ 4 -999 4 0 0 4 ]{53: LT}           // i < n ?
[ 4 -999 4 0 1 ]{54: IFNZRO 18}      // if true -> loop body (pc=18)

[ 4 -999 4 0 ]{18: GETBP}            // body: print i; i=i+1;
[ 4 -999 4 0 2 ]{19: CSTI 1}         // push 1
[ 4 -999 4 0 2 1 ]{21: ADD}          // addr(i)
[ 4 -999 4 0 3 ]{22: LDI}            // load i
[ 4 -999 4 0 0 ]{23: PRINTI}         // print i
0 [ 4 -999 4 0 0 ]{24: INCSP -1}     // pop print arg
[ 4 -999 4 0 ]{26: GETBP}            // compute i = i + 1
[ 4 -999 4 0 2 ]{27: CSTI 1}         // push 1
[ 4 -999 4 0 2 1 ]{29: ADD}          // addr(i)
[ 4 -999 4 0 3 ]{30: GETBP}          // push BP
[ 4 -999 4 0 3 2 ]{31: CSTI 1}       // push 1
[ 4 -999 4 0 3 2 1 ]{33: ADD}        // addr(i)
[ 4 -999 4 0 3 3 ]{34: LDI}          // load i
[ 4 -999 4 0 3 0 ]{35: CSTI 1}       // push 1
[ 4 -999 4 0 3 0 1 ]{37: ADD}        // i+1
[ 4 -999 4 0 3 1 ]{38: STI}          // store back to i
[ 4 -999 4 1 1 ]{39: INCSP -1}       // pop temp
[ 4 -999 4 1 ]{41: INCSP 0}          // no-op
[ 4 -999 4 1 ]{43: GETBP}            // test again
[ 4 -999 4 1 2 ]{44: CSTI 1}         // push 1
[ 4 -999 4 1 2 1 ]{46: ADD}          // addr(i)
[ 4 -999 4 1 3 ]{47: LDI}            // load i
[ 4 -999 4 1 1 ]{48: GETBP}          // push BP
[ 4 -999 4 1 1 2 ]{49: CSTI 0}       // push 0
[ 4 -999 4 1 1 2 0 ]{51: ADD}        // addr(n)
[ 4 -999 4 1 1 2 ]{52: LDI}          // load n
[ 4 -999 4 1 1 4 ]{53: LT}           // i < n ?
[ 4 -999 4 1 1 ]{54: IFNZRO 18}      // if true -> body

[ 4 -999 4 1 ]{18: GETBP}            // body: print i
[ 4 -999 4 1 2 ]{19: CSTI 1}
[ 4 -999 4 1 2 1 ]{21: ADD}
[ 4 -999 4 1 3 ]{22: LDI}
[ 4 -999 4 1 1 ]{23: PRINTI}
1 [ 4 -999 4 1 1 ]{24: INCSP -1}     // pop print arg
[ 4 -999 4 1 ]{26: GETBP}            // i = i + 1
[ 4 -999 4 1 2 ]{27: CSTI 1}
[ 4 -999 4 1 2 1 ]{29: ADD}
[ 4 -999 4 1 3 ]{30: GETBP}
[ 4 -999 4 1 3 2 ]{31: CSTI 1}
[ 4 -999 4 1 3 2 1 ]{33: ADD}
[ 4 -999 4 1 3 3 ]{34: LDI}
[ 4 -999 4 1 3 1 ]{35: CSTI 1}
[ 4 -999 4 1 3 1 1 ]{37: ADD}
[ 4 -999 4 1 3 2 ]{38: STI}
[ 4 -999 4 2 2 ]{39: INCSP -1}
[ 4 -999 4 2 ]{41: INCSP 0}
[ 4 -999 4 2 ]{43: GETBP}            // test again
[ 4 -999 4 2 2 ]{44: CSTI 1}
[ 4 -999 4 2 2 1 ]{46: ADD}
[ 4 -999 4 2 3 ]{47: LDI}
[ 4 -999 4 2 2 ]{48: GETBP}
[ 4 -999 4 2 2 2 ]{49: CSTI 0}
[ 4 -999 4 2 2 2 0 ]{51: ADD}
[ 4 -999 4 2 2 2 ]{52: LDI}
[ 4 -999 4 2 2 4 ]{53: LT}
[ 4 -999 4 2 1 ]{54: IFNZRO 18}      // still true -> body

[ 4 -999 4 2 ]{18: GETBP}            // body: print i
[ 4 -999 4 2 2 ]{19: CSTI 1}
[ 4 -999 4 2 2 1 ]{21: ADD}
[ 4 -999 4 2 3 ]{22: LDI}
[ 4 -999 4 2 2 ]{23: PRINTI}
2 [ 4 -999 4 2 2 ]{24: INCSP -1}     // pop print arg
[ 4 -999 4 2 ]{26: GETBP}            // i = i + 1
[ 4 -999 4 2 2 ]{27: CSTI 1}
[ 4 -999 4 2 2 1 ]{29: ADD}
[ 4 -999 4 2 3 ]{30: GETBP}
[ 4 -999 4 2 3 2 ]{31: CSTI 1}
[ 4 -999 4 2 3 2 1 ]{33: ADD}
[ 4 -999 4 2 3 3 ]{34: LDI}
[ 4 -999 4 2 3 2 ]{35: CSTI 1}
[ 4 -999 4 2 3 2 1 ]{37: ADD}
[ 4 -999 4 2 3 3 ]{38: STI}
[ 4 -999 4 3 3 ]{39: INCSP -1}
[ 4 -999 4 3 ]{41: INCSP 0}
[ 4 -999 4 3 ]{43: GETBP}            // test again
[ 4 -999 4 3 2 ]{44: CSTI 1}
[ 4 -999 4 3 2 1 ]{46: ADD}
[ 4 -999 4 3 3 ]{47: LDI}
[ 4 -999 4 3 3 ]{48: GETBP}
[ 4 -999 4 3 3 2 ]{49: CSTI 0}
[ 4 -999 4 3 3 2 0 ]{51: ADD}
[ 4 -999 4 3 3 2 ]{52: LDI}
[ 4 -999 4 3 3 4 ]{53: LT}           // check 3 < 4
[ 4 -999 4 3 1 ]{54: IFNZRO 18}      // true -> body

[ 4 -999 4 3 ]{18: GETBP}            // body: print i
[ 4 -999 4 3 2 ]{19: CSTI 1}
[ 4 -999 4 3 2 1 ]{21: ADD}
[ 4 -999 4 3 3 ]{22: LDI}
[ 4 -999 4 3 3 ]{23: PRINTI}
3 [ 4 -999 4 3 3 ]{24: INCSP -1}     // pop print arg
[ 4 -999 4 3 ]{26: GETBP}            // i = i + 1
[ 4 -999 4 3 2 ]{27: CSTI 1}
[ 4 -999 4 3 2 1 ]{29: ADD}
[ 4 -999 4 3 3 ]{30: GETBP}
[ 4 -999 4 3 3 2 ]{31: CSTI 1}
[ 4 -999 4 3 3 2 1 ]{33: ADD}
[ 4 -999 4 3 3 3 ]{34: LDI}
[ 4 -999 4 3 3 3 ]{35: CSTI 1}
[ 4 -999 4 3 3 3 1 ]{37: ADD}
[ 4 -999 4 3 3 4 ]{38: STI}          // i becomes 4
[ 4 -999 4 4 4 ]{39: INCSP -1}
[ 4 -999 4 4 ]{41: INCSP 0}
[ 4 -999 4 4 ]{43: GETBP}            // test again
[ 4 -999 4 4 2 ]{44: CSTI 1}
[ 4 -999 4 4 2 1 ]{46: ADD}
[ 4 -999 4 4 3 ]{47: LDI}            // load i=4
[ 4 -999 4 4 4 ]{48: GETBP}          // load n
[ 4 -999 4 4 4 2 ]{49: CSTI 0}
[ 4 -999 4 4 4 2 0 ]{51: ADD}
[ 4 -999 4 4 4 2 ]{52: LDI}          // n=4
[ 4 -999 4 4 4 4 ]{53: LT}           // 4<4 ? -> 0
[ 4 -999 4 4 0 ]{54: IFNZRO 18}      // false -> exit loop
[ 4 -999 4 4 ]{56: INCSP -1}         // pop test result
[ 4 -999 4 ]{58: RET 0}              // return from main
[ 4 ]{4: STOP}                       // halt VM

_________________________________________________________________________

EXERCISE 8.3 - Emotional status: empty stack, drought in the soul

Absyn.fs:
    and expr =
    ...
    | PreInc of access                 (* C/C++/Java/C# ++i or ++a[e] *)
    | PreDec of access                 (* C/C++/Java/C# --i or --a[e] *)

Comp.fs:
    and cExpr (e : expr) (varEnv : varEnv) (funEnv : funEnv) : instr list = 
    ...
    | PreInc acc -> cAccess acc varEnv funEnv @ [DUP; LDI; CSTI 1; ADD; STI; LDI]
    | PreDec acc -> cAccess acc varEnv funEnv @ [DUP; LDI; CSTI 1; SUB; STI; LDI]
    ...

Clex.fsl:
    rule Token = parse
    ...
    | "++"            { PLUSONE } 
    | "--"            { MINUSONE } 
    ...

CPar.fsy:
    %token PLUS MINUS TIMES DIV MOD PLUSONE MINUSONE

    ExprNotAccess:
    ...
    | PLUSONE Access                      { PreInc($2)          }
    | MINUSONE Access                     { PreDec($2)          }
    ...

_________________________________________________________________________

EXERCISE 8.4 - Emotional status: slightly unamused

> compileToFile (fromFile "ex8.c") "ex8.out";;
val it: Machine.instr list =
  [LDARGS; CALL (0, "L1"); STOP; Label "L1"; INCSP 1; GETBP; CSTI 0; ADD;
   CSTI 20000000; STI; INCSP -1; GOTO "L3"; Label "L2"; GETBP; CSTI 0; ADD;
   GETBP; CSTI 0; ADD; LDI; CSTI 1; SUB; STI; INCSP -1; INCSP 0; Label "L3";
   GETBP; CSTI 0; ADD; LDI; IFNZRO "L2"; INCSP -1; RET -1]

ex8.out: 24 19 0 5 25 15 1 13 0 0 1 0 20000000 12 15 -1 16 35 13 0 0 1 13 0 0 1 11 0 1 2 12 15 -1 15 0 13 0 0 1 11 18 18 15 -1 21 -1
prog1: 0 20000000 16 7 0 1 2 9 18 4 25

In the bytecode of ex8, there is a lot of commands regarding the stack and cleanup of the entire program itself, 
whereas in the bytecode of prog1 it doesn't work with the stack and is more intuitive to fairly intelligent humans. 
Prog1 is more just a direct "translation" of the function in ex8.c. 


> compileToFile (fromFile "ex13.c") "ex13.out";;
val it: Machine.instr list =
  [LDARGS; CALL (1, "L1"); STOP; 
  Label "L1"; INCSP 1; GETBP; CSTI 1; ADD; CSTI 1889; STI; INCSP -1; GOTO "L3"; 
  Label "L2"; GETBP; CSTI 1; ADD; GETBP; CSTI 1; ADD; LDI; CSTI 1; ADD; STI; INCSP -1; GETBP; CSTI 1; ADD; LDI;
   CSTI 4; MOD; CSTI 0; EQ; IFZERO "L7"; GETBP; CSTI 1; ADD; LDI; CSTI 100; MOD; CSTI 0; EQ; NOT; IFNZRO "L9"; 
   GETBP; CSTI 1; ADD; LDI; CSTI 400; MOD; CSTI 0; EQ; GOTO "L8"; 
  Label "L9"; CSTI 1; 
  Label "L8"; GOTO "L6";
  Label "L7"; CSTI 0; 
  Label "L6"; IFZERO "L4"; GETBP; CSTI 1; ADD; LDI; PRINTI; INCSP -1; GOTO "L5"; 
  Label "L4"; INCSP 0; 
  Label "L5"; INCSP 0;
  Label "L3"; GETBP; CSTI 1; ADD; LDI; GETBP; CSTI 0; ADD; LDI; LT; IFNZRO "L2"; INCSP -1; RET 0]

ex13.out:
24 19 1 5 25 15 1 13 0 1 1 0 1889 12 15 -1 16 95 13 0 1 1 13 0 1 1 11 0 1 1 12 15 -1 13 0 1 1 11 0 4 5 0 0 6 17 77 13 0 1 1 11 0 100 5 0 0 6 8 18 73 13 0 1 1 11 0 400 5 0 0 6 16 75 0 1 16 79 0 0 17 91 13 0 1 1 11 22 15 -1 16 93 15 0 15 0 13 0 1 1 11 13 0 0 1 11 7 18 18 15 -1 21 0

The bytecode uses labels both as conditionals and loops mimicking if statement and while loops. 
For example L3 acts as a conditional in the while loop (y < n). 

_________________________________________________________________________

Exercise 8.5: 

In Absyn.fs:
and expr =                                                         
  ...
  | Ternary of expr * expr * expr    (* Conditional expression      *)

In CLex.fsi: 
rule Token = parse
  ...
  | '?'             { QUESTION }
  | ':'             { COLON }                     
  ...

In CPar.fsy: 
ExprNotAccess:
  ...
  | Expr QUESTION Expr COLON Expr       { Ternary($1, $3, $5) }
  ...
;

In Comp.fs: 
and cExpr (e : expr) (varEnv : varEnv) (funEnv : funEnv) : instr list = 
    match e with
    ...
    | Ternary(e1, e2, e3) ->
      let labelse = newLabel()
      let labend = newLabel()
      cExpr e1 varEnv funEnv @ [IFZERO labelse] 
      @ cExpr e2 varEnv funEnv @ [GOTO labend]
      @ [Label labelse] @ cExpr e3 varEnv funEnv
      @ [Label labend]
    ...

Tested with test85.c: 
void main() { 
  int i; 
  i=1; 
  print (i ? 1 : 0);
}

_________________________________________________________________________

Exercise 8.6: 

In Absyn.fs:
and stmt =                                                         
  ...
  | Switch of expr * (int * stmt) list(* Switch with integer cases    *)
  ...

In CLex.fsl:
let keyword s =
    match s with
    ...
    | "case"    -> CASE
    | "switch"  -> SWITCH
    ...

In CPar.fsy: 
StmtM: 
  ...
  | SWITCH LPAR Expr RPAR LBRACE Cases RBRACE    { Switch($3, $6)       }
  ...
;

Cases:
    /* empty */                                 { [] }
  | Case Cases                                  { $1 :: $2 }
;

Case:
    CASE CSTINT COLON Block                     { ($2, $4) }
;

In Comp.fs: 
let rec cStmt stmt (varEnv : varEnv) (funEnv : funEnv) : instr list = 
    match stmt with
    ...
    | Switch(e, cases) ->
      let labend = newLabel()
      let labcases = List.map (fun _ -> newLabel()) cases
      let pre = cExpr e varEnv funEnv
      let tests = List.concat (List.map2 (fun (c, _) lab -> [DUP; CSTI c; EQ; IFNZRO lab]) cases labcases)
      let aftertests = [INCSP -1]
      let bodies = List.concat (List.map2 (fun (c, body) lab -> [Label lab] @ [INCSP -1] @ cStmt body varEnv funEnv @ [GOTO labend]) cases labcases)
      pre @ tests @ aftertests @ bodies @ [Label labend]
    ...