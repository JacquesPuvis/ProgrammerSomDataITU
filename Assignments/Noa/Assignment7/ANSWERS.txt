
Exercise 8.1

compileToFile (fromFile "ex3.c") "ex3.out";;  
val it: Machine.instr list =
  [LDARGS;                                          //load command line with argument n
  CALL (1, "L1");                                   //call main
  STOP;                                             //end program
  Label "L1";                                       //void main(int n)
    INCSP 1;                                        //int i
    GETBP; CSTI 1; ADD;                             //adress for i 
    CSTI 0; STI; INCSP -1;                          //i = 0
    GOTO "L3";                                      //go to condition of while loop
  Label "L2";                                       //loop body
    GETBP; CSTI 1; ADD; LDI; PRINTI; INCSP -1;      //get i and print i 
    GETBP; CSTI 1; ADD; GETBP; CSTI 1; ADD;         //get i, get i, add 1
        LDI; CSTI 1; ADD; STI; INCSP -1; 
    INCSP 0;                                        //no operation
  Label "L3";                                       //condition i < n
    GETBP; CSTI 1; ADD; LDI;                        //get i
    GETBP; CSTI 0; ADD; LDI;                        //get n
    LT;                                             //<
    IFNZRO "L2";                                    //if true go to L2
    INCSP -1;                                       //if not true pop condition from stack (end loop)
    RET 0]                                          //function end

  compile "ex5";;
val it: Machine.instr list =
  [LDARGS;                                          //load command line with argument n
  CALL (1, "L1");                                   //call main          
  STOP;                                             //end program
  Label "L1";                                       //void main(int n)
    INCSP 1;                                        //inr r
    GETBP; CSTI 1; ADD;                             //get adress for r
    GETBP; CSTI 0; ADD; LDI;                        //get n
    STI; INCSP -1;                                  //r = n 
    INCSP 1;                                        //new int r
    GETBP; CSTI 0; ADD; LDI;                        //get n
    GETBP; CSTI 2; ADD;                             //get adress for new r
    CALL (2, "L2");                                 //call square function (L2) with 2 arguments
    INCSP -1;                                       //end block (end call to square)
    GETBP; CSTI 2; ADD; LDI;                        //get r         
    PRINTI; INCSP -1;                               //print r
    INCSP -1;                                       //pop print argument (end block) and make new r a free variable
    GETBP; CSTI 1; ADD; LDI;                        //get r
    PRINTI; INCSP -1;                               //print r
    INCSP -1;                                       //end block
    RET 0;                                          //function end
  Label "L2";                                       //void square(int i, int *rp)
    GETBP; CSTI 1; ADD; LDI;                        //get *rp (pointer value to r) (argument index 1)
    GETBP; CSTI 0; ADD; LDI;                        //get i (argument index 0)
    GETBP; CSTI 0; ADD; LDI;                        //get i (argument index 0)
    MUL;                                            //multiply i with i
    STI;                                            //assign *rp the value of the multiplication
    INCSP -1;                                       //pop leftover addresses, end block
    INCSP 0;                                        //no operation
    RET 1]                                          //return *rp
