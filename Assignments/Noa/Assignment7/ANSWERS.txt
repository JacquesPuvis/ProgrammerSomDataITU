
Exercise 8.1

part 1

compileToFile (fromFile "ex3.c") "ex3.out";;  
val it: Machine.instr list =
  [LDARGS;                                          //load command line with argument n
  CALL (1, "L1");                                   //call main
  STOP;                                             //end program
  Label "L1";                                       //void main(int n)
    INCSP 1;                                        //int i
    GETBP; CSTI 1; ADD;                             //adress for i 
    CSTI 0; STI; INCSP -1;                          //i = 0
    GOTO "L3";                                      //go to condition of while loop
  Label "L2";                                       //loop body
    GETBP; CSTI 1; ADD; LDI; PRINTI; INCSP -1;      //get i and print i 
    GETBP; CSTI 1; ADD; GETBP; CSTI 1; ADD;         //get i, get i, add 1
        LDI; CSTI 1; ADD; STI; INCSP -1; 
    INCSP 0;                                        //no operation
  Label "L3";                                       //condition i < n
    GETBP; CSTI 1; ADD; LDI;                        //get i
    GETBP; CSTI 0; ADD; LDI;                        //get n
    LT;                                             //<
    IFNZRO "L2";                                    //if true go to L2
    INCSP -1;                                       //if not true pop condition from stack (end loop)
    RET 0]                                          //function end


part 2

  compile "ex5";;
val it: Machine.instr list =
  [LDARGS;                                          //load command line with argument n
  CALL (1, "L1");                                   //call main          
  STOP;                                             //end program
  Label "L1";                                       //void main(int n)
    INCSP 1;                                        //inr r
    GETBP; CSTI 1; ADD;                             //get adress for r
    GETBP; CSTI 0; ADD; LDI;                        //get n
    STI; INCSP -1;                                  //r = n 
    INCSP 1;                                        //new int r
    GETBP; CSTI 0; ADD; LDI;                        //get n
    GETBP; CSTI 2; ADD;                             //get adress for new r
    CALL (2, "L2");                                 //call square function (L2) with 2 arguments
    INCSP -1;                                       //end block (end call to square)
    GETBP; CSTI 2; ADD; LDI;                        //get r         
    PRINTI; INCSP -1;                               //print r
    INCSP -1;                                       //pop print argument (end block) and make new r a free variable
    GETBP; CSTI 1; ADD; LDI;                        //get r
    PRINTI; INCSP -1;                               //print r
    INCSP -1;                                       //end block
    RET 0;                                          //function end
  Label "L2";                                       //void square(int i, int *rp)
    GETBP; CSTI 1; ADD; LDI;                        //get *rp (pointer value to r) (argument index 1)
    GETBP; CSTI 0; ADD; LDI;                        //get i (argument index 0)
    GETBP; CSTI 0; ADD; LDI;                        //get i (argument index 0)
    MUL;                                            //multiply i with i
    STI;                                            //assign *rp the value of the multiplication
    INCSP -1;                                       //pop leftover addresses, end block
    INCSP 0;                                        //no operation
    RET 1]                                          //return *rp

part 3

[ ]{0: LDARGS}                       // push command-line arg n (=4)
[ 4 ]{1: CALL 1 5}                   // call main(n); set frame; jump to L1 at pc=5
[ 4 -999 4 ]{5: INCSP 1}             // allocate local i (slot [BP+1])
[ 4 -999 4 0 ]{7: GETBP}             // push BP
[ 4 -999 4 0 2 ]{8: CSTI 1}          // push 1
[ 4 -999 4 0 2 1 ]{10: ADD}          // compute &i = BP+1
[ 4 -999 4 0 3 ]{11: CSTI 0}         // push 0
[ 4 -999 4 0 3 0 ]{13: STI}          // i = 0
[ 4 -999 4 0 0 ]{14: INCSP -1}       // pop temp
[ 4 -999 4 0 ]{16: GOTO 43}          // jump to while test

[ 4 -999 4 0 ]{43: GETBP}            // while test: push BP
[ 4 -999 4 0 2 ]{44: CSTI 1}         // push 1
[ 4 -999 4 0 2 1 ]{46: ADD}          // addr(i)
[ 4 -999 4 0 3 ]{47: LDI}            // load i
[ 4 -999 4 0 0 ]{48: GETBP}          // push BP
[ 4 -999 4 0 0 2 ]{49: CSTI 0}       // push 0
[ 4 -999 4 0 0 2 0 ]{51: ADD}        // addr(n)
[ 4 -999 4 0 0 2 ]{52: LDI}          // load n
[ 4 -999 4 0 0 4 ]{53: LT}           // i < n ?
[ 4 -999 4 0 1 ]{54: IFNZRO 18}      // if true -> loop body (pc=18)

[ 4 -999 4 0 ]{18: GETBP}            // body: print i; i=i+1;
[ 4 -999 4 0 2 ]{19: CSTI 1}         // push 1
[ 4 -999 4 0 2 1 ]{21: ADD}          // addr(i)
[ 4 -999 4 0 3 ]{22: LDI}            // load i
[ 4 -999 4 0 0 ]{23: PRINTI}         // print i
0 [ 4 -999 4 0 0 ]{24: INCSP -1}     // pop print arg
[ 4 -999 4 0 ]{26: GETBP}            // compute i = i + 1
[ 4 -999 4 0 2 ]{27: CSTI 1}         // push 1
[ 4 -999 4 0 2 1 ]{29: ADD}          // addr(i)
[ 4 -999 4 0 3 ]{30: GETBP}          // push BP
[ 4 -999 4 0 3 2 ]{31: CSTI 1}       // push 1
[ 4 -999 4 0 3 2 1 ]{33: ADD}        // addr(i)
[ 4 -999 4 0 3 3 ]{34: LDI}          // load i
[ 4 -999 4 0 3 0 ]{35: CSTI 1}       // push 1
[ 4 -999 4 0 3 0 1 ]{37: ADD}        // i+1
[ 4 -999 4 0 3 1 ]{38: STI}          // store back to i
[ 4 -999 4 1 1 ]{39: INCSP -1}       // pop temp
[ 4 -999 4 1 ]{41: INCSP 0}          // no-op
[ 4 -999 4 1 ]{43: GETBP}            // test again
[ 4 -999 4 1 2 ]{44: CSTI 1}         // push 1
[ 4 -999 4 1 2 1 ]{46: ADD}          // addr(i)
[ 4 -999 4 1 3 ]{47: LDI}            // load i
[ 4 -999 4 1 1 ]{48: GETBP}          // push BP
[ 4 -999 4 1 1 2 ]{49: CSTI 0}       // push 0
[ 4 -999 4 1 1 2 0 ]{51: ADD}        // addr(n)
[ 4 -999 4 1 1 2 ]{52: LDI}          // load n
[ 4 -999 4 1 1 4 ]{53: LT}           // i < n ?
[ 4 -999 4 1 1 ]{54: IFNZRO 18}      // if true -> body

[ 4 -999 4 1 ]{18: GETBP}            // body: print i
[ 4 -999 4 1 2 ]{19: CSTI 1}
[ 4 -999 4 1 2 1 ]{21: ADD}
[ 4 -999 4 1 3 ]{22: LDI}
[ 4 -999 4 1 1 ]{23: PRINTI}
1 [ 4 -999 4 1 1 ]{24: INCSP -1}     // pop print arg
[ 4 -999 4 1 ]{26: GETBP}            // i = i + 1
[ 4 -999 4 1 2 ]{27: CSTI 1}
[ 4 -999 4 1 2 1 ]{29: ADD}
[ 4 -999 4 1 3 ]{30: GETBP}
[ 4 -999 4 1 3 2 ]{31: CSTI 1}
[ 4 -999 4 1 3 2 1 ]{33: ADD}
[ 4 -999 4 1 3 3 ]{34: LDI}
[ 4 -999 4 1 3 1 ]{35: CSTI 1}
[ 4 -999 4 1 3 1 1 ]{37: ADD}
[ 4 -999 4 1 3 2 ]{38: STI}
[ 4 -999 4 2 2 ]{39: INCSP -1}
[ 4 -999 4 2 ]{41: INCSP 0}
[ 4 -999 4 2 ]{43: GETBP}            // test again
[ 4 -999 4 2 2 ]{44: CSTI 1}
[ 4 -999 4 2 2 1 ]{46: ADD}
[ 4 -999 4 2 3 ]{47: LDI}
[ 4 -999 4 2 2 ]{48: GETBP}
[ 4 -999 4 2 2 2 ]{49: CSTI 0}
[ 4 -999 4 2 2 2 0 ]{51: ADD}
[ 4 -999 4 2 2 2 ]{52: LDI}
[ 4 -999 4 2 2 4 ]{53: LT}
[ 4 -999 4 2 1 ]{54: IFNZRO 18}      // still true -> body

[ 4 -999 4 2 ]{18: GETBP}            // body: print i
[ 4 -999 4 2 2 ]{19: CSTI 1}
[ 4 -999 4 2 2 1 ]{21: ADD}
[ 4 -999 4 2 3 ]{22: LDI}
[ 4 -999 4 2 2 ]{23: PRINTI}
2 [ 4 -999 4 2 2 ]{24: INCSP -1}     // pop print arg
[ 4 -999 4 2 ]{26: GETBP}            // i = i + 1
[ 4 -999 4 2 2 ]{27: CSTI 1}
[ 4 -999 4 2 2 1 ]{29: ADD}
[ 4 -999 4 2 3 ]{30: GETBP}
[ 4 -999 4 2 3 2 ]{31: CSTI 1}
[ 4 -999 4 2 3 2 1 ]{33: ADD}
[ 4 -999 4 2 3 3 ]{34: LDI}
[ 4 -999 4 2 3 2 ]{35: CSTI 1}
[ 4 -999 4 2 3 2 1 ]{37: ADD}
[ 4 -999 4 2 3 3 ]{38: STI}
[ 4 -999 4 3 3 ]{39: INCSP -1}
[ 4 -999 4 3 ]{41: INCSP 0}
[ 4 -999 4 3 ]{43: GETBP}            // test again
[ 4 -999 4 3 2 ]{44: CSTI 1}
[ 4 -999 4 3 2 1 ]{46: ADD}
[ 4 -999 4 3 3 ]{47: LDI}
[ 4 -999 4 3 3 ]{48: GETBP}
[ 4 -999 4 3 3 2 ]{49: CSTI 0}
[ 4 -999 4 3 3 2 0 ]{51: ADD}
[ 4 -999 4 3 3 2 ]{52: LDI}
[ 4 -999 4 3 3 4 ]{53: LT}           // check 3 < 4
[ 4 -999 4 3 1 ]{54: IFNZRO 18}      // true -> body

[ 4 -999 4 3 ]{18: GETBP}            // body: print i
[ 4 -999 4 3 2 ]{19: CSTI 1}
[ 4 -999 4 3 2 1 ]{21: ADD}
[ 4 -999 4 3 3 ]{22: LDI}
[ 4 -999 4 3 3 ]{23: PRINTI}
3 [ 4 -999 4 3 3 ]{24: INCSP -1}     // pop print arg
[ 4 -999 4 3 ]{26: GETBP}            // i = i + 1
[ 4 -999 4 3 2 ]{27: CSTI 1}
[ 4 -999 4 3 2 1 ]{29: ADD}
[ 4 -999 4 3 3 ]{30: GETBP}
[ 4 -999 4 3 3 2 ]{31: CSTI 1}
[ 4 -999 4 3 3 2 1 ]{33: ADD}
[ 4 -999 4 3 3 3 ]{34: LDI}
[ 4 -999 4 3 3 3 ]{35: CSTI 1}
[ 4 -999 4 3 3 3 1 ]{37: ADD}
[ 4 -999 4 3 3 4 ]{38: STI}          // i becomes 4
[ 4 -999 4 4 4 ]{39: INCSP -1}
[ 4 -999 4 4 ]{41: INCSP 0}
[ 4 -999 4 4 ]{43: GETBP}            // test again
[ 4 -999 4 4 2 ]{44: CSTI 1}
[ 4 -999 4 4 2 1 ]{46: ADD}
[ 4 -999 4 4 3 ]{47: LDI}            // load i=4
[ 4 -999 4 4 4 ]{48: GETBP}          // load n
[ 4 -999 4 4 4 2 ]{49: CSTI 0}
[ 4 -999 4 4 4 2 0 ]{51: ADD}
[ 4 -999 4 4 4 2 ]{52: LDI}          // n=4
[ 4 -999 4 4 4 4 ]{53: LT}           // 4<4 ? -> 0
[ 4 -999 4 4 0 ]{54: IFNZRO 18}      // false -> exit loop
[ 4 -999 4 4 ]{56: INCSP -1}         // pop test result
[ 4 -999 4 ]{58: RET 0}              // return from main
[ 4 ]{4: STOP}                       // halt VM

EXERCISE 8.3 - Emotional status: empty stack, drought in the soul

Absyn.fs:
    and expr =
    ...
    | PreInc of access                 (* C/C++/Java/C# ++i or ++a[e] *)
    | PreDec of access                 (* C/C++/Java/C# --i or --a[e] *)

Comp.fs:
    and cExpr (e : expr) (varEnv : varEnv) (funEnv : funEnv) : instr list = 
    ...
    | PreInc acc -> cAccess acc varEnv funEnv @ [DUP; LDI; CSTI 1; ADD; STI; LDI]
    | PreDec acc -> cAccess acc varEnv funEnv @ [DUP; LDI; CSTI 1; SUB; STI; LDI]
    ...

Clex.fsl:
    rule Token = parse
    ...
    | "++"            { PLUSONE } 
    | "--"            { MINUSONE } 
    ...

CPar.fsy:
    %token PLUS MINUS TIMES DIV MOD PLUSONE MINUSONE

    ExprNotAccess:
    ...
    | PLUSONE Access                      { PreInc($2)          }
    | MINUSONE Access                     { PreDec($2)          }
    ...

EXERCISE 8.4 - Emotional status: slightly unamused

